package org.sagebionetworks.repo.model.dbo.dao;

import java.io.IOException;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.sagebionetworks.repo.model.Annotations;
import org.sagebionetworks.repo.model.DatastoreException;
import org.sagebionetworks.repo.model.NamedAnnotations;
import org.sagebionetworks.repo.model.SchemaCache;
import org.sagebionetworks.repo.model.jdo.JDOSecondaryPropertyUtils;
import org.sagebionetworks.schema.ObjectSchema;
import org.sagebionetworks.schema.adapter.JSONEntity;

public class SchemaSerializationUtils {
	@SuppressWarnings("rawtypes")
	public static byte[] mapDtoFieldsToAnnotations(Object dto, ObjectSchema schema) throws DatastoreException {
		Map<String, ObjectSchema> schemaProperties = schema.getProperties();
		NamedAnnotations properties = new NamedAnnotations();
		Annotations a = properties.getPrimaryAnnotations();
		for (String propertyName : schemaProperties.keySet()) {
				try {
					Field field = dto.getClass().getDeclaredField(propertyName);
					field.setAccessible(true);
					Map<String, List<String>> stringAnnots = a.getStringAnnotations();
					Class fieldType = field.getType();
					if (!(fieldType.equals(String.class))) {
						throw new RuntimeException("Unsupported field type "+fieldType);
					}
					stringAnnots.put(propertyName, Arrays.asList(new String[]{(String)field.get(dto)}));
				} catch (NoSuchFieldException e) {
					// since the object is generated by the schema, this should never happen
					throw new RuntimeException(e);
				} catch (IllegalAccessException e) {
					throw new RuntimeException(e);
				}
		}
		try {
			return JDOSecondaryPropertyUtils.compressAnnotations(properties);
		} catch (IOException e) {
			throw new DatastoreException(e);
		}
		
	}
	
	@SuppressWarnings("rawtypes")
	public static void mapAnnotationsToDtoFields(byte[] compressedProperties, Object dto, ObjectSchema schema) throws DatastoreException {
		NamedAnnotations properties = null;
		try {
			properties = JDOSecondaryPropertyUtils.decompressedAnnotations(compressedProperties);
		} catch (IOException e) {
			throw new DatastoreException(e);
		}		
		
		Map<String, ObjectSchema> schemaProperties = schema.getProperties();
		Annotations a = properties.getPrimaryAnnotations();
		Map<String, List<String>> stringAnnots = a.getStringAnnotations();
		for (String propertyName : schemaProperties.keySet()) {
			try {
				Field field = dto.getClass().getDeclaredField(propertyName);
				field.setAccessible(true);
				Class fieldType = field.getType();
				if (!(fieldType.equals(String.class))) {
					throw new RuntimeException("Unsupported field type "+fieldType);
				}
				List<String> values = stringAnnots.get(propertyName);
				if (values!=null && values.size()>0) {
					field.set(dto, values.get(0));
				}
			} catch (NoSuchFieldException e) {
				// since the object is generated by the schema, this should never happen
				throw new RuntimeException(e);
			} catch (IllegalAccessException e) {
				throw new RuntimeException(e);
			}			
		}
	}

	// because of how the JSON schemas are defined, the subtype of AccessRequirement
	// passed in will include a field called 'parameters' not defined in AccessRequirement itself
	
	public static String PARAMETERS_FIELD_NAME = "parameters";
	
	public static Object getParamsField(Object dto) throws DatastoreException {
		try {
			Field field = dto.getClass().getDeclaredField(PARAMETERS_FIELD_NAME);
			field.setAccessible(true);
			return field.get(dto);
		} catch (SecurityException e) {
			throw new DatastoreException(e);
		} catch (NoSuchFieldException e) {
			throw new DatastoreException("no field "+PARAMETERS_FIELD_NAME+" in object of class "+dto.getClass());
		} catch (IllegalAccessException e) {
			throw new DatastoreException(e);
		}
	}
	
	public static Object setParamsField(Object dto) throws DatastoreException {
		try {
			Field field = dto.getClass().getDeclaredField(PARAMETERS_FIELD_NAME);
			field.setAccessible(true);
			Object params = field.getType().newInstance();
			field.set(dto, params);
			return params;
		} catch (SecurityException e) {
			throw new DatastoreException(e);
		} catch (NoSuchFieldException e) {
			throw new DatastoreException("no field "+PARAMETERS_FIELD_NAME+" in object of class "+dto.getClass());
		} catch (IllegalAccessException e) {
			throw new DatastoreException(e);
		} catch (InstantiationException e) {
			throw new DatastoreException(e);
		}
	}
	
	public static <T extends JSONEntity> ObjectSchema getParamsSchema(T dto) throws DatastoreException {
		try {
			Field field = dto.getClass().getDeclaredField(PARAMETERS_FIELD_NAME);
			Class<? extends JSONEntity> paramType = (Class<? extends JSONEntity>)field.getType();
			return SchemaCache.getSchema(paramType);
		} catch (SecurityException e) {
			throw new DatastoreException(e);
		} catch (NoSuchFieldException e) {
			throw new DatastoreException(e);
		}		
	}
	
	
}
