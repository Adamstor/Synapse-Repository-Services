package org.sagebionetworks.javadoc.web.services;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

import java.io.File;
import java.net.URL;
import java.util.Iterator;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import com.sun.javadoc.AnnotationDesc;
import com.sun.javadoc.AnnotationTypeDoc;
import com.sun.javadoc.ClassDoc;
import com.sun.javadoc.MethodDoc;
import com.sun.tools.javadoc.Main;

/**
 * Test for the SpringMVCDoclet
 * @author jmhill
 *
 */
public class SpringMVCDocletTest {
	
	File sampleSourceFile;
	File classpathFile;
	
	@Before
	public void before(){
		// Lookup the test files.
		sampleSourceFile = findFileOnClasspath("ExampleController.java");
		// Find the classpath file generated by the maven-dependency-plugin
		String propertyName = "auto-generated-classpath";
		String propertyValue = System.getProperty(propertyName);
		System.out.println(propertyValue);
		assertNotNull("The property: "+propertyName+" must be set -D"+propertyName+"=<path to: auto-generated-classpath.txt>", propertyValue);
		classpathFile = new File(propertyValue);
	}
	
	public static File findFileOnClasspath(String fileName){
		URL url = SpringMVCDocletTest.class.getClassLoader().getResource(fileName);
		assertNotNull("Failed to find: "+fileName+" on the classpath", url);
		File file = new File(url.getFile().replaceAll("%20", " "));
		assertTrue(file.exists());
		return file;
	}


	@Test
	public void testMain(){
		// Run a sample javadoc
		int result = Main.execute(SpringMVCDocletTest.class.getClassLoader(), new String[]{
			"-doclet", SpringMVCDoclet.class.getName(),
			"-classpath",
			"@"+classpathFile.getAbsolutePath(),
			"-verbose",
			sampleSourceFile.getAbsolutePath()
			});
		assertEquals(0, result);
	}

	
	@Test
	public void testControllerIterator(){
		// Create 3 clases
		ClassDoc[] testClassDocs = new ClassDoc[]{
				createMockClassDoc("one", new String[]{Controller.class.getName()}),
				createMockClassDoc("two", new String[]{"not.a.controller"}),
				createMockClassDoc("three", new String[]{Controller.class.getName()}),
		};
		// Create our iterator
		Iterator<ClassDoc> it = SpringMVCDoclet.controllerIterator(testClassDocs);
		assertNotNull(it);
		int count = 0;
		while(it.hasNext()){
			ClassDoc cd = it.next();
			assertNotNull(cd);
			assertTrue("Two should have been filtered out as it was not a controller", "one".equals(cd.qualifiedName()) || "three".equals(cd.qualifiedName()));
			count++;
		}
		assertEquals(2, count);
	}
	
	@Test
	public void testRequestMappingIterator(){
		// Create 3 clases
		MethodDoc[] testDocs = new MethodDoc[]{
				createMockMethodDoc("one", new String[]{"some.other.annotation",RequestMapping.class.getName()}),
				createMockMethodDoc("two", new String[]{"not.a.controller"}),
				createMockMethodDoc("three", new String[]{RequestMapping.class.getName()}),
				createMockMethodDoc("four", null),
		};
		// Create our iterator
		Iterator<MethodDoc> it = SpringMVCDoclet.requestMappingIterator(testDocs);
		assertNotNull(it);
		int count = 0;
		while(it.hasNext()){
			MethodDoc cd = it.next();
			assertNotNull(cd);
			assertTrue("Two and Four should have been filtered out: "+cd.qualifiedName(), "one".equals(cd.qualifiedName()) || "three".equals(cd.qualifiedName()));
			count++;
		}
		assertEquals(2, count);
	}
	
	/**
	 * Create a mock ClassDoc for testing.
	 * @param isController - True of the class represents a Spring controller.
	 * @return
	 */
	public ClassDoc createMockClassDoc(String name, String[] annotations){
		ClassDoc mockDoc = Mockito.mock(ClassDoc.class);
		AnnotationDesc[] mockAnnotations = mockAnnotations(annotations);
		when(mockDoc.annotations()).thenReturn(mockAnnotations);
		when(mockDoc.qualifiedName()).thenReturn(name);
		return mockDoc;
	}
	
	/**
	 * Create a mock method for testing.
	 * @param name
	 * @param annotations
	 * @return
	 */
	public MethodDoc createMockMethodDoc(String name, String[] annotations){
		MethodDoc mockDoc = Mockito.mock(MethodDoc.class);
		AnnotationDesc[] mockAnnotations = mockAnnotations(annotations);
		when(mockDoc.annotations()).thenReturn(mockAnnotations);
		when(mockDoc.qualifiedName()).thenReturn(name);
		return mockDoc;
	}

	/**
	 * Create a mock annotations
	 * @param toStringValue
	 * @return
	 */
	private AnnotationTypeDoc mockAnnotationType(String toStringValue) {
		AnnotationTypeDoc atd = Mockito.mock(AnnotationTypeDoc.class);
		when(atd.qualifiedName()).thenReturn(toStringValue);
		return atd;
	}
	
	/**
	 * Mock an array of AnnotationDesc.
	 * @param names
	 * @return
	 */
	public AnnotationDesc[] mockAnnotations(String[] names){
		if(names == null) return null;
		AnnotationDesc[] array = new AnnotationDesc[names.length];
		for(int i=0; i<names.length; i++){
			AnnotationDesc ad = Mockito.mock(AnnotationDesc.class);
			AnnotationTypeDoc atd = mockAnnotationType(names[i]);
			when(ad.annotationType()).thenReturn(atd);
			array[i] = ad;
		}
		return array;
	}
}
